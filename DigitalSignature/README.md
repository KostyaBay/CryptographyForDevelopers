# CryptographyForDevelopers
#### Distributed Lab

Реалізація алгоритму цифрового підпису RSA

:small_blue_diamond: Вимоги:

Ознайомтеся з відповідним алгоритмом, дослідіть порядок обчислень та реалізуйте функції генерації ключової пари, обчислення геш-значення, підписання довільного повідомлення та перевірки цифрового підпису. <br>
Також зробіть тестовий запуск програми для демонстрації роботи цифрового підпису та переконайтесь, що отриманий підпис успішно перевіряється вашою функцією перевірки, тоді як для пошкодженого підпису (або повідомлення, або відкритого  ключа) функція перевірки повертає false. <br>
Маючи свою реалізацію алгоритму цифрового підпису на еліптичних кривих напишіть програмний код, що виконує демонстрацію використання цифрового підпису для довільного повідомлення. Бажано щоб програма у зручній формі повертала та приймала дані, щоб можливо було підписувати та перевіряти повідомлення на різних пристроях. <br>

:small_blue_diamond: Етапи виконання практичного завдання:

1. Реалізація RSA, або ECDSA, або Schnorr, або Ring traceable signatures
2. Тестування та демонстрація роботи

:small_blue_diamond: Результат:

Основний алгоритм міститься у папці RSA (файл `RSA.go`):
| Функція                      | Метод                       |  Реалізовано  |
|------------------------------|-----------------------------|:-------------:|
| ● Генерація ключів | GenKey (keyLength int) |:heavy_check_mark:|
| ● Гешування повідомлення SHA-256 | Hashing (mess string) |:heavy_check_mark:|
| ● Підписування повідомлення | DigitSign (mess string, e, n *big.Int) |:heavy_check_mark:|
| ● Верифікація підпису | Verification (mess string, c, d, n *big.Int) |:heavy_check_mark:|

Тестування та демонсрація відбуваються у файлі `main.go`:
| Тестування         | Метод                      |   Реалізовано    |
|--------------------|----------------------------|:----------------:|
| ● Тест використання ЦП | TestDigSign() |:heavy_check_mark:|

Користувачу надані наступні права:
- обирати довжину ключів при генерації (key length),
- самостійно вводити згенеровані ключі (private\public keys), 
- вводити довільне повідомлення для підписування (message), 
- самостійно вводити згенерований підпис для верифікації (digital signature).

Приклад генерації ключів (довжиною 2048 бітів):
![2048_test_DS_1.png](..%2F..%2F..%2F..%2FDesktop%2F2048_test_DS_1.png)

Приклад підпису повідомлення *"Message for test!"*:
![2048_test_DS_2.png](..%2F..%2F..%2F..%2FDesktop%2F2048_test_DS_2.png)

1 part та 2 part of keys розділені " ; ".

Приклад верифікації підписаного повідомлення:
![2048_test_DS_3.png](..%2F..%2F..%2F..%2FDesktop%2F2048_test_DS_3.png)

Приклад верифікації пошкодженого підпису:
![2048_Negtest1_DS.png](..%2F..%2F..%2F..%2FDesktop%2F2048_Negtest1_DS.png)

Приклад верифікації пошкодженого повідомлення:
![2048_Negtest2_DS.png](..%2F..%2F..%2F..%2FDesktop%2F2048_Negtest2_DS.png)

Приклад верифікації пошкодженого відкритого ключа (Public Key):
![2048_Negtest3_DS.png](..%2F..%2F..%2F..%2FDesktop%2F2048_Negtest3_DS.png)

Для запуску коду потрібно:
-
1. Завантажити файли **main.go** (файл для перевірки та демонстрації використання ЦП) та **go.mod** (файл конфігурацій).
2. Також треба завантажити файл **RSA.go** з самою реалізацією ЦП RSA у відповідній папці.
3. Відкрити папку з завантаженими файлами (рекомендовано використовувати IDE для мови Go, наприклад [GoLand від JetBrains](https://www.jetbrains.com/go/)).
4. Cкомпілювати та запустити код (в більшості IDE виконується командою **go build**).
5. Результат буде виведено в консоль за допомогою функції fmt.Println() вбудованої бібліотеки fmt, яку перед використанням імпортуємо - import "fmt".
